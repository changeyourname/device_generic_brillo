#!/system/bin/sh -e
# Copyright 2015 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Directory for (persistent) WiFi information.
data_dir=/data/misc/wifi

# Configuration for hostapd daemon.
ap_config_file="${data_dir}/hostapd.conf"

# Configuration for wpa_supplicant daemon.
client_config_file="${data_dir}/wpa_supplicant.conf"

# DHCP server daemon directory.
dhcp_dir=/data/misc/dhcp

# Storage for the current nameservers.
nameserver_list="${dhcp_dir}/nameservers.txt"

# Use these DNS servers if none are supplied.
google_domain_name_servers="8.8.8.8 8.8.4.4"

pid_file_for () {
  # Return the pid file for |process_name|.
  local process_name="$1"
  echo "${data_dir}/${process_name}.pid"
}

pid_for () {
  # Return process id for |process_name|.
  local pid_file="$(pid_file_for "${process_name}")"
  if [ -z "${pid_file}" -o ! -f "${pid_file}" ] ; then
    return 1
  fi
  local pid
  pid="$(cat "${pid_file}")"
  if [ -z "${pid}" ] ; then
    return 1
  fi
  echo "${pid}"
}

kill_process () {
  # Kill |process_name|.
  local process_name="$1"
  local pid

  # It's not an error if the process we want to kill does not exist.
  pid="$(pid_for "${process_name}")" || return 0
  rm -f "$(pid_file_for ${process_name})"
  kill "${pid}" || return 0
  sleep 1
}

signal_process () {
  # Signal |process_name| with |signal|.  Do not remove PID file.
  local process_name="$1"
  local signal="$2"
  local pid

  # It is an error if the pid is not found for signal.
  pid="$(pid_for "${process_name}")" || return 1
  kill "-${signal}" "${pid}" || return 1
  if [ "${signal}" != "0" ] ; then
    sleep 1
  fi
}

kill_dhcp_for () {
  # Kill the dhcp process running on |interface|.
  local interface="$1"
  local pid="$(getprop dhcp.${interface}.pid)"
  if [ -z "${pid}" ] ; then
    return 0
  fi
  kill "${pid}" || true
}

kill_servers () {
  # Kills the running supplicant.
  kill_process wpa_supplicant
  kill_process hostapd
  kill_process dnsmasq
}

run_supplicant () {
  # Startup supplicant process on |interface|.
  local interface="$1"
  wpa_supplicant -B -d -Dnl80211 -i"${interface}" -c "$client_config_file" \
      -P"$(pid_file_for wpa_supplicant)"

  # Wait until supplicant has fully daemonized.
  for try in $(seq 1 3) ; do
    sleep 1
    if [ -f $(pid_file_for wpa_supplicant) ] ; then
      break
    fi
  done

  # Trigger a re-configuration in wpa_supplicant, which will initiate scans.
  signal_process wpa_supplicant HUP ||
      log -t wifi_connect "Could not launch scan in wpa_supplicant."
}

start_supplicant () {
  # Start up wpa_supplicant on |interface|.
  kill_servers
  local interface
  interface="$(wifi_init client)"
  make_config_dir
  get_supplicant_config "$@" > "$client_config_file"
  chmod 644 "$client_config_file"
  run_supplicant "${interface}"
  echo "${interface}"
}

start_hostapd () {
  # Start up hostapd on |interface|.
  kill_servers
  local interface
  interface="$(wifi_init ap)"
  make_config_dir
  get_hostap_config "${interface}" "$@" > "$ap_config_file"
  chmod 644 "$ap_config_file"
  hostapd -B -d -P "$(pid_file_for hostapd)" "$ap_config_file"
  echo "${interface}"
}

make_config_dir () {
  # Creates the parent directory for the supplicant configuration.
  mkdir -m 755 -p "$data_dir"
}

get_supplicant_config () {
  # Returns the wpa_supplicant.conf content.
  # Usage: get_supplicant_config <ssid> [passphrase]
  local ssid="$1"
  local passphrase="$2"
  local wpa_mode

  echo "ap_scan=1"
  echo "network={"
  echo "	ssid=\"$ssid\""
  if [ -z "$passphrase" ] ; then
    echo "	key_mgmt=NONE"
  else
    echo "	psk=\"$passphrase\""
  fi
  echo "}"
}

get_hostap_config () {
  # Returns the hostapd.conf content.
  # Usage: get_hostap_config <interface> <ssid> [passphrase]
  local interface="$1"
  local ssid="$2"
  local passphrase="$3"

  echo "interface=$interface"
  echo "ssid=$ssid"
  echo "channel=1"
  echo "driver=nl80211"
  if [ -n "$passphrase" ] ; then
    echo "auth_algs=1"
    echo "wpa=2"
    echo "wpa_key_mgmt=WPA-PSK"
    echo "rsn_pairwise=CCMP"
    echo "wpa_passphrase=$passphrase"
  fi
  # Hack -- the prima driver cannot accept a zero tail-length.
  echo "vendor_elements=dd0411223301"
}

is_link_connected () {
  local interface="$1"
  for word in $(iw "${interface}" link) ; do
    if [ "$word" = "Connected" ] ; then
      return 0
    fi
  done
  return 1
}

is_ip_connected () {
  local interface="$1"
  for word in $(ifconfig "${interface}") ; do
    if [ "$word" = "inet" ] ; then
      return 0
    fi
  done
  return 1
}

connect_client () {
  # Start up a client.
  local interface
  interface=$(start_supplicant "$@")

  for try in $(seq 1 30) ; do
    if is_link_connected "${interface}"; then
      start_dhcp "${interface}"
      return
    fi
    sleep 1
  done
  log -t wifi_connect "Association timed out."
  return 1
}

start_dhcp () {
  # Starts a DHCP client.  dhcpcd is configured to run a second instance
  # of this script.  This child instance will call the "configure_client"
  # method, which will apply the IP configuration gained from DHCP.  After
  # starting dhcpcd, the parent process monitors the progress of dhcpcd
  # below.
  local interface="$1"
  kill_dhcp_for "${interface}"
  rm -f "${dhcp_dir}"/*
  dhcpcd --script "$0" --env FROM_DHCPCD=1 "${interface}"
  for try in $(seq 1 15) ; do
    if [ -e "${nameserver_list}" ]; then
      echo "Connected!"
      start_dns
      return 0
    fi
    sleep 1
  done

  log -t wifi_connect "DHCP timed out."
  return 1
}

start_dns () {
  # Starts local DNS proxy for bionic clients.
  kill_process dnsmasq
  local nameservers=$(cat "${nameserver_list}")
  if [ -z "${nameservers}" ] ; then
    nameservers="${google_domain_name_servers}"
  fi
  local args="--no-hosts --listen-address=127.0.0.1 --no-resolv"
  for dns_server in $nameservers; do
    args="${args} --server=${dns_server}"
  done

  # dnsmasq appears to read from stdin, even when not in debug mode.
  dnsmasq $args "--pid-file=$(pid_file_for dnsmasq)" < /dev/null
}

ensure_dns_running () {
  if ! signal_process dnsmasq 0; then
    log -t wifi_connect "Starting dnsmasq."
    start_dns
  fi
}

configure_client () {
  # Configures IP parameters from a successful run of the dhcp client.
  # All parameters (including "$interface" below) are provided in the
  # environment by dhcpcd.
  if [ -z "$interface" ] ; then
    return 1
  fi

  if [ -n "$new_ip_address" ] ; then
    ifconfig "$interface" "$new_ip_address" \
        netmask "$new_subnet_mask" 2>/dev/null || true
  fi

  for router in $new_routers $old_routers; do
    route add default gw "$router" && break
  done

  if [ "$reason" = "BOUND" -o "$reason" = "REBOOT" ] ; then
    echo "$new_domain_name_servers" > "${nameserver_list}"
  fi
}

get_dnsmasq_server_config () {
  # Returns the dnsmasq.conf content.
  # Usage: get_dnsmasq_config <interface> <ip_prefix>
  local interface="$1"
  local ip_prefix="$2"
  echo "port=0"
  echo "bind-interfaces"
  echo "log-dhcp"
  echo "dhcp-range=${ip_prefix}.10,${ip_prefix}.100"
  echo "interface=${interface}"
  echo "dhcp-leasefile="${dhcp_dir}/dnsmasq.leases""
}

setup_ap () {
  # Start up an access point.
  local interface
  interface="$(start_hostapd "$@")"
  local ip_prefix=192.168.69
  kill_dhcp_for "${interface}"
  ifconfig "${interface}" "${ip_prefix}.1"
  local config_file="${data_dir}/dnsmasq.conf"
  get_dnsmasq_server_config "${interface}" "${ip_prefix}" > "${config_file}"
  chmod 644 "$config_file"
  dnsmasq --conf-file="${config_file}" --pid-file="$(pid_file_for dnsmasq)"
}

resume_client () {
  # Start up supplicant and DHCP if configuration is left over from a previous
  # boot.
  if [ ! -f "${client_config_file}" ] ; then
    log -t wifi_connect "No saved configuration."
    return 0
  fi
  log -t wifi_connect "Starting up using saved configuration."
  kill_servers
  local interface
  interface="$(wifi_init client)"
  chmod 644 "$client_config_file"
  run_supplicant "${interface}"
  start_dhcp "${interface}"
}

get_wifi_interfaces () {
  local word
  local last_word
  for word in $(iw dev); do
    if [ "${last_word}" = "Interface" ] ; then
      echo "${word}"
    fi
    last_word="${word}"
  done
}

get_status () {
  # Get status for the client interface.
  local interface
  for interface in $(get_wifi_interfaces); do
    if is_link_connected "${interface}"; then
      if is_ip_connected "${interface}"; then
        ensure_dns_running
        iw "${interface}" link
        ifconfig "${interface}"
        return
      else
        echo "${interface} has link but has no IP address"
      fi
    fi
  done
  echo "We are not connected."
}

main () {
  if [ "$VERBOSE" = 1 ] ; then
    set -x
  fi
  if [ "$FROM_DHCPCD" = 1 ] ; then
    configure_client
    return
  fi

  local cmd="$1"
  if [ -z "$cmd" ] ; then
    resume_client
    return
  fi

  shift

  case "$cmd" in
    ap) setup_ap "$@" ;;
    boot) resume_client ;;
    client) connect_client "$@" ;;
    status) get_status ;;
    disable) kill_servers ;;
    *)
      log -t wifi_connect "Run with unknown command $cmd"
      echo "Command '$cmd' not supported"
      echo "Usage: $0 <ap|client> <ssid> [passphrase] [more-ap-opts...]"
      return 1
  esac
}

main "$@"
